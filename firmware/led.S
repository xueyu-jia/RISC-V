#
# 文件: led_blink.s
# 描述: 基于指定链接脚本的 RV32I LED 闪烁程序
# 日期: 2025年5月10日
#
# 链接脚本回顾：
#   .text.init 段起始于 0x80000000
#   .text 段在 .text.init 之后，并对齐到 0x1000
#   .data 段起始于 0x80400000
#

# 定义 LED 控制寄存器的内存地址
# IMPORTANT: 这个地址必须与你实际硬件的 GPIO 寄存器地址相符！
.set LED_ADDR, 0xFFFFF000+0x00000100

# 定义延时循环的迭代次数
# 这个值需要根据你的 CPU 时钟频率和每条指令的时钟周期来调整，
# 以达到你期望的延时时间 (例如，0.5 秒)。
# 较大的值会产生更长的延时。
.set DELAY_COUNT, 5000000 # 500万次循环，对于一个50MHz的CPU可能约为0.1秒 (假设平均2个周期/指令)

# =============================================================================
# 代码段 (.text.init)
# 按照链接脚本，此段将放置在 0x80000000
# =============================================================================
.section .text.init
.globl _start           # 声明 _start 标签为全局可见，作为程序的入口点

_start:
    # 对于简单的点灯程序，通常不需要设置栈指针 (sp)，
    # 因为没有函数调用、局部变量或中断处理。
    # 但在更复杂的嵌入式程序中，这是第一步。
    # 例如: li sp, _end + 0x1000 # 设置栈指针在 .bss 段之后的一个安全地址

    # 直接跳转到主循环。
    #main_blink_loop 会被链接器正确地解析，即使它位于不同的段 (.text)。
    j main_blink_loop

# =============================================================================
# 代码段 (.text)
# 按照链接脚本，此段将在 .text.init 之后，并对齐到 0x1000
# 对于这个小小的 .text.init，.text 段很可能在 0x80001000 处开始。
# =============================================================================
.section .text

main_blink_loop:
    li x1,0x01
    li x2,LED_ADDR
    sw x1,0x0(x2)
loop:
    j    loop 



# =============================================================================
# 数据段 (.data, .data.string, .bss)
# 按照链接脚本，这些段将放置在 0x80400000 及其之后
# =============================================================================
.section .data
# 如果有常量或已初始化的变量，可以在这里定义。
# 例如: my_constant: .word 0xDEADBEEF

.section .data.string
# 如果程序需要存储字符串常量，可以在这里定义。
# 例如: welcome_msg: .string "Hello, RISC-V!\n"

.section .bss
# 未初始化数据段。
# 如果有未初始化的全局或静态变量，它们将在这里分配空间。
# 链接器会设置 _end 标签，指向 .bss 段的末尾。
# 例如: .lcomm my_uninit_var, 4 # 为 my_uninit_var 分配 4 字节空间
